/// Define helper functions and trait implementations for working with the
/// `proc_block_v2` glue generated by `wit_bindgen_rust`.
#[macro_export]
macro_rules! generate_support {
    ($($proc_block:ident)::*) => {
        mod support {
            use std::{fmt::{self, Display, Formatter}, str::FromStr};
            use $($proc_block)::*::*;
            use $crate::ndarray::{Dimension, IntoDimension};

            pub fn parse_arg<T>(args: &[Argument], name: &str) -> Result<T, ArgumentError>
            where
                T: FromStr,
                T::Err: Display,
            {
                for arg in args {
                    if arg.name == name {
                        return arg.value.parse::<T>().map_err(|e| ArgumentError {
                            name: name.to_string(),
                            reason: ArgumentErrorReason::InvalidValue(e.to_string()),
                        });
                    }
                }

                Err(ArgumentError {
                    name: name.to_string(),
                    reason: ArgumentErrorReason::NotFound,
                })
            }

            pub fn get_input_tensor<'t>(tensors: &'t [Tensor], name: &str) -> Result<&'t Tensor, KernelError> {
                tensors.iter()
                    .find(|t| t.name == name)
                    .ok_or_else(|| KernelError::InvalidInput(InvalidInput {
                            name: name.to_string(),
                            reason: InvalidInputReason::NotFound,
                        }))
            }

            impl Tensor {
                pub fn new<T, S, Dims>(name: impl Into<String>, array: $crate::ndarray::ArrayBase<S, Dims>) -> Self
                where
                    T: ValueType,
                    S: $crate::ndarray::Data<Elem=T>,
                    Dims: $crate::ndarray::Dimension,
                {
                    let dimensions = array.shape()
                        .iter()
                        .map(|&d| d as u32)
                        .collect();

                    Tensor {
                        name: name.into(),
                        dimensions,
                        element_type: T::ELEMENT_TYPE,
                        buffer: Vec::new(),
                    }
                }

                pub fn with_name(self, name: impl Into<String>) -> Self {
                    Tensor {
                        name: name.into(),
                        ..self
                    }
                }

                pub fn view<T>(&self) -> Result<$crate::ndarray::ArrayViewD<'_, T>, KernelError>
                where
                    T: ValueType,
                {
                    if self.element_type != T::ELEMENT_TYPE {
                        return Err(KernelError::InvalidInput(InvalidInput {
                            name: self.name.clone(),
                            reason: InvalidInputReason::UnsupportedShape,
                        }));
                    }

                    todo!();
                }

                pub fn view_with_dimensions<T, Dims>(&self) -> Result<$crate::ndarray::ArrayView<'_, T, Dims>, KernelError>
                where
                    T: ValueType,
                    Dims: $crate::ndarray::Dimension,
                {
                    self.view::<T>()?
                        .into_dimensionality::<Dims>()
                        .map_err(|e| InvalidInput::other(&self.name, e).into())
                }

                pub fn view_1d<T>(&self) -> Result<$crate::ndarray::ArrayView1<'_, T>, KernelError>
                where
                    T: ValueType,
                {
                    self.view_with_dimensions()
                }

                pub fn view_2d<T>(&self) -> Result<$crate::ndarray::ArrayView2<'_, T>, KernelError>
                where
                    T: ValueType,
                {
                    self.view_with_dimensions()
                }

                pub fn view_mut<T>(&mut self) -> Result<$crate::ndarray::ArrayViewMutD<'_, T>, KernelError>
                where
                    T: ValueType,
                {
                    if self.element_type != T::ELEMENT_TYPE {
                        return Err(KernelError::InvalidInput(InvalidInput {
                            name: self.name.clone(),
                            reason: InvalidInputReason::UnsupportedShape,
                        }));
                    }

                    todo!();
                }

                pub fn view_with_dimensions_mut<T, Dims>(&mut self) -> Result<$crate::ndarray::ArrayViewMut<'_, T, Dims>, KernelError>
                where
                    T: ValueType,
                    Dims: $crate::ndarray::Dimension,
                {
                    // FIXME: It'd be nice if we didn't need to make this copy,
                    // but the borrow checker isn't able to figure out that
                    // the into_dimensionality() call consumes our view and
                    // therefore the mutable borrow is finished.
                    let name = self.name.clone();

                    self.view_mut::<T>()?
                        .into_dimensionality::<Dims>()
                        .map_err(|e| InvalidInput::other(name, e).into())
                }
            }

            impl TensorConstraint {
                pub fn new(
                    name: impl Into<String>,
                    element_type: ElementTypeConstraint,
                    dimensions: impl Into<Dimensions>,
                ) -> Self {
                    TensorConstraint {
                        name: name.into(),
                        element_type,
                        dimensions: dimensions.into(),
                    }
                }

                pub fn numeric(
                    name: impl Into<String>,
                    dimensions: impl Into<Dimensions>,
                ) -> Self {
                    TensorConstraint {
                        name: name.into(),
                        element_type: !ElementTypeConstraint::UTF8,
                        dimensions: dimensions.into(),
                    }
                }
            }

            impl From<Vec<u32>> for Dimensions {
                fn from(fixed: Vec<u32>) -> Self {
                    Dimensions::Fixed(fixed)
                }
            }

            impl KernelError {
                pub fn unsupported_shape(tensor_name: impl Into<String>) -> Self {
                    KernelError::InvalidInput(InvalidInput {
                        name: tensor_name.into(),
                        reason: InvalidInputReason::UnsupportedShape,
                    })
                }
            }

            impl InvalidInput {
                pub fn unsupported_shape(tensor_name: impl Into<String>) -> Self {
                    InvalidInput {
                        name: tensor_name.into(),
                        reason: InvalidInputReason::UnsupportedShape,
                    }
                }

                pub fn not_found(tensor_name: impl Into<String>) -> Self {
                    InvalidInput {
                        name: tensor_name.into(),
                        reason: InvalidInputReason::NotFound,
                    }
                }

                pub fn invalid_value(tensor_name: impl Into<String>, error: impl Display) -> Self {
                    InvalidInput {
                        name: tensor_name.into(),
                        reason: InvalidInputReason::InvalidValue(error.to_string()),
                    }
                }

                pub fn other(tensor_name: impl Into<String>, reason: impl Display) -> Self {
                    InvalidInput {
                        name: tensor_name.into(),
                        reason: InvalidInputReason::Other(reason.to_string()),
                    }
                }
            }

            impl Metadata {
                pub fn new(name: impl Into<String>, version: impl Into<String>) -> Self {
                    Metadata {
                        name: name.into(),
                        version: version.into(),
                        tags: Vec::new(),
                        description: None,
                        homepage: None,
                        repository: None,
                        arguments: Vec::new(),
                        inputs: Vec::new(),
                        outputs: Vec::new(),
                    }
                }

                pub fn with_tag(mut self, tag: impl Into<String>) -> Self {
                    self.tags.push(tag.into());
                    self
                }

                pub fn with_description(mut self, description: impl Into<String>) -> Self {
                    let description = description.into();
                    if !description.is_empty() {
                        self.description = Some(description);
                    }

                    self
                }

                pub fn with_homepage(mut self, homepage: impl Into<String>) -> Self {
                    let homepage = homepage.into();
                    if !homepage.is_empty() {
                        self.homepage = Some(homepage);
                    }

                    self
                }

                pub fn with_repository(mut self, repository: impl Into<String>) -> Self {
                    let repository = repository.into();
                    if !repository.is_empty() {
                        self.repository = Some(repository);
                    }

                    self
                }

                pub fn with_argument(mut self, arg: ArgumentMetadata) -> Self {
                    self.arguments.push(arg);
                    self
                }

                pub fn with_input(mut self, input: TensorMetadata) -> Self {
                    self.inputs.push(input);
                    self
                }

                pub fn with_output(mut self, output: TensorMetadata) -> Self {
                    self.outputs.push(output);
                    self
                }
            }

            impl ArgumentMetadata {
                pub fn new(name: impl Into<String>) -> Self {
                    ArgumentMetadata {
                        name: name.into(),
                        description: None,
                        default_value: None,
                        hints: Vec::new(),
                    }
                }

                pub fn with_description(mut self, description: impl Into<String>) -> Self {
                    let description = description.into();
                    if !description.is_empty() {
                        self.description = Some(description);
                    }
                    self
                }

                pub fn with_default_value(mut self, default_value: impl ToString) -> Self {
                    let default_value = default_value.to_string();
                    if !default_value.is_empty() {
                        self.default_value = Some(default_value);
                    }
                    self
                }

                pub fn with_hint(mut self, hint: ArgumentHint) -> Self {
                    self.hints.push(hint);
                    self
                }
            }

            impl TensorMetadata {
                pub fn new(name: impl Into<String>) -> Self {
                    TensorMetadata {
                        name: name.into(),
                        description: None,
                        hints: Vec::new(),
                    }
                }

                pub fn with_description(mut self, description: impl Into<String>) -> Self {
                    let description = description.into();
                    if !description.is_empty() {
                        self.description = Some(description);
                    }

                    self
                }

                pub fn with_hint(mut self, hint: TensorHint) -> Self {
                    self.hints.push(hint);
                    self
                }
            }

            impl From<InvalidInput> for KernelError {
                fn from(i: InvalidInput) -> Self {
                    KernelError::InvalidInput(i)
                }
            }

            pub trait ValueType: $crate::ValueType {
                const ELEMENT_TYPE: ElementType;
            }

            impl ValueType for u8 { const ELEMENT_TYPE: ElementType = ElementType::U8; }
            impl ValueType for i8 { const ELEMENT_TYPE: ElementType = ElementType::I8; }
            impl ValueType for u16 { const ELEMENT_TYPE: ElementType = ElementType::U16; }
            impl ValueType for i16 { const ELEMENT_TYPE: ElementType = ElementType::I16; }
            impl ValueType for u32 { const ELEMENT_TYPE: ElementType = ElementType::U32; }
            impl ValueType for i32 { const ELEMENT_TYPE: ElementType = ElementType::I32; }
            impl ValueType for f32 { const ELEMENT_TYPE: ElementType = ElementType::F32; }
            impl ValueType for u64 { const ELEMENT_TYPE: ElementType = ElementType::U64; }
            impl ValueType for i64 { const ELEMENT_TYPE: ElementType = ElementType::I64; }
            impl ValueType for f64 { const ELEMENT_TYPE: ElementType = ElementType::F64; }

            impl Display for KernelError {
                fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                    match self {
                        KernelError::InvalidInput(i) => i.fmt(f),
                        KernelError::Other(msg) => write!(f, "{}", msg),
                    }
                }
            }

            impl std::error::Error for KernelError {
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        KernelError::InvalidInput(i) => todo!(),
                        KernelError::Other(_) => None,
                    }
                }
            }

            impl Display for InvalidInput {
                fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                    write!(f, "The \"{}\" input tensor was invalid", self.name)
                }
            }

            impl Display for InvalidInputReason {
                fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                    match self {
                        InvalidInputReason::Other(msg) => write!(f, "{msg}"),
                        InvalidInputReason::NotFound => write!(f, "Not found"),
                        InvalidInputReason::InvalidValue(msg) => write!(f, "Invalid value: {msg}"),
                        InvalidInputReason::UnsupportedShape => write!(f, "Unsupported shape"),
                    }
                }
            }

            impl std::error::Error for InvalidInputReason {}

            impl Display for ArgumentError {
                fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                    write!(f, "The \"{}\" argument is invalid", self.name)
                }
            }

            impl std::error::Error for ArgumentError {
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.reason)
                }
            }

            impl Display for ArgumentErrorReason {
                fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                    match self {
                        ArgumentErrorReason::Other(msg) => write!(f, "{msg}"),
                        ArgumentErrorReason::NotFound => {
                            write!(f, "The argument wasn't defined")
                        },
                        ArgumentErrorReason::InvalidValue(msg) => {
                            write!(f, "Invalid value: {msg}")
                        },
                    }
                }
            }

            impl std::error::Error for ArgumentErrorReason {}
        }
    };
}
